# HPC_Jacobi-Methodd
This repository contains the implementation of the **Jacobi Method for the iterative solution of Poisson's Equation in one dimension (1D)**. It utilizes High-Performance Computing (HPC) techniques to efficiently solve this equation, providing a numerical solution for problems in fields such as physics, engineering, and applied sciences. It provides three distinct implementations: **sequential, threaded (using pthreads), and process-based (using fork)**, each with its specific characteristics and optimizations.

# Prerequisites

Before proceeding with the optimization analysis, ensure the following prerequisites are met:
* **Linux Environment:** The optimization analysis is conducted on a Linux-based operating system. Make sure you have access to a Linux environment to compile and run the code.
* **GCC Compiler:**  Ensure that the GCC compiler is installed on your system. You can install GCC on Linux using package managers like `apt` (for Debian-based distributions) or `yum` (for Red Hat-based distributions). 

   **For Debian-based distributions:**
  
       sudo apt update
       sudo apt install gcc

    **For Red Hat-based distributions:**
  
       sudo yum install gcc

## 1. Sequential Implementation: 
The code is written in C and includes a sequential implementation of the algorithm along with a bash script for executing performance tests. This implementation is stored in the **SecuencialJabobi** folder. Also, we explore the impact of different optimization levels (-O1, -O2, -O3). The compiled executables and their corresponding performance results of optimization are stored in the **"Optimization_CPU** folder.

### Optimization levels
  **-O1:** Basic optimization level, focusing on improving compilation time and code size without sacrificing runtime performance significantly.
  
  **-O2:** Medium optimization level, including additional optimizations such as loop unrolling and function inlining to improve runtime performance further.
  
  **-O3:** Highest optimization level, enabling aggressive optimizations such as vectorization and loop restructuring to maximize runtime performance, potentially at the cost of increased compilation time.

### Code overview
The Jacobi iterative method is used to solve Poissonâ€™s equation in one dimension. It iteratively updates the solution until convergence is achieved. The provided implementation includes a **function to perform the Jacobi iterations** and another **function to write the solution to a file**. Additionally, a **bash script** is included to run performance tests on the sequential implementation. It records the execution time for each test run in a **csv file**.

### Files
  * **jacobiSecuencial.c:** Contains the implementation of the Jacobi iterative algorithm along with the main function for running the solver.
  * **jacobiSecuencial.sh:** Bash script to execute performance tests on the sequential implementation.
  * **resultadoJacobiSecuencial.csv:** Output file generated by the script to store performance results.

### Usage
  **Compilation and optimization:** 
  
  * _Command to compile the code without optimization:_
    
        gcc -g jacobiSecuencial.c -o jacobiSecuencialExe
    
            
  * _Commands used to compile the code with each optimization level using the GCC comppiler:_
  
        gcc -O1 jacobiSecuencial.c -o jacobiSecuencialExe
        gcc -O2 jacobiSecuencial.c -o jacobiSecuencialExe
        gcc -O3 jacobiSecuencial.c -o jacobiSecuencialExe
        
  **Running the performance tests:** 
   
       ./jacobiSecuencialScript.sh

### Performance analysis
Pros:
  * Straightforward implementation. 
  * Suitable for small array sizes or systems where parallelism is not feasible.
    
Cons:
   * Limited scalability for large datasets.
   * Execution time increases linearly with the number of iterations.

### Performance results
The CSV files contain execution times for different array sizes, providing insights into the impact of optimization on the solver's performance. These results can be analyzed to understand the execution time trends and scalability of the algorithm.

## 2. Multi-threading implementation
The code is written in C and includes a multi-threaded implementation of the algorithm along with a bash script for executing performance tests. The solver is parallelized using POSIX threads (pthread library) to leverage multi-core processors for faster computation.











    
